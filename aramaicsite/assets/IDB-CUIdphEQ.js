var u=Object.defineProperty;var d=(s,e,t)=>e in s?u(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var c=(s,e,t)=>d(s,typeof e!="symbol"?e+"":e,t);import{o}from"./index-Dob3nYDb.js";class w{constructor(e){c(this,"upgradeQueuePromise",Promise.resolve());this.dbName=e}async getVersion(){return new Promise((e,t)=>{const n=indexedDB.open(this.dbName);n.onsuccess=()=>{const a=n.result,r=a.version;a.close(),e(r)},n.onerror=()=>t(n.error)}).catch(()=>1)}async _openDBRaw(e){let t=await o(this.dbName);if(t.objectStoreNames.contains(e))return t.close(),t=await o(this.dbName),t;t.close();const a=await this.getVersion()+1;return await o(this.dbName,a,{upgrade(r){r.objectStoreNames.contains(e)||r.createObjectStore(e)}})}async _openDB(e){return this.upgradeQueuePromise=this.upgradeQueuePromise.then(this._openDBRaw.bind(this,e)),await this.upgradeQueuePromise,await o(this.dbName)}async set(e,t,n){const r=(await this._openDB(e)).transaction(e,"readwrite");await r.store.put(n,t),await r.done}async get(e,t){const a=(await this._openDB(e)).transaction(e,"readonly"),r=await a.store.get(t);return await a.done,r}}const i=new Map;function h(s){return i.has(s)||i.set(s,new w(s)),i.get(s)}class g{static async get(e,t,n){try{return await h(e).get(t,n)}catch{}}static async set(e,t,n,a){}}export{g as I};
