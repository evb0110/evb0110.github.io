var w=Object.defineProperty;var d=(s,t,e)=>t in s?w(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e;var c=(s,t,e)=>d(s,typeof t!="symbol"?t+"":t,e);import{o as a}from"./index-Dob3nYDb.js";class h{constructor(t){c(this,"upgradeQueuePromise",Promise.resolve());this.dbName=t}async getVersion(){return new Promise((t,e)=>{const r=indexedDB.open(this.dbName);r.onsuccess=()=>{const n=r.result,o=n.version;n.close(),t(o)},r.onerror=()=>e(r.error)}).catch(()=>1)}async _openDBRaw(t){let e=await a(this.dbName);if(e.objectStoreNames.contains(t))return e.close(),e=await a(this.dbName),e;e.close();const n=await this.getVersion()+1;return await a(this.dbName,n,{upgrade(o){o.objectStoreNames.contains(t)||o.createObjectStore(t)}})}async _openDB(t){return this.upgradeQueuePromise=this.upgradeQueuePromise.then(this._openDBRaw.bind(this,t)),await this.upgradeQueuePromise,await a(this.dbName)}async set(t,e,r){const o=(await this._openDB(t)).transaction(t,"readwrite");await o.store.put(r,e),await o.done}async get(t,e){const n=(await this._openDB(t)).transaction(t,"readonly"),o=await n.store.get(e);return await n.done,o}}const i=new Map;function u(s){return i.has(s)||i.set(s,new h(s)),i.get(s)}class g{static async get(t,e,r){try{return await u(t).get(e,r)}catch(n){window.console.error(n)}}static async set(t,e,r,n){try{return await u(t).set(e,r,n)}catch(o){window.console.error(o)}}}export{g as I};
