var E=Object.defineProperty;var L=(r,t,s)=>t in r?E(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var d=(r,t,s)=>L(r,typeof t!="symbol"?t+"":t,s);import{bv as M,c as y,y as b,d as F,a1 as j,ag as T,r as k,a2 as w,bw as B}from"./index-BvwX90FD.js";import{o as G}from"./index-Dob3nYDb.js";import{u as K}from"./index-CFiEmgVU.js";var m,P=new Uint8Array(16);function q(){if(!m&&(m=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!m))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return m(P)}var z=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const A={randomUUID:z};function J(r,t,s){if(A.randomUUID&&!t&&!r)return A.randomUUID();r=r||{};var e=r.random||(r.rng||q)();return e[6]=e[6]&15|64,e[8]=e[8]&63|128,M(e)}const O=/[\p{M}]|[\u0701-\u0709]|[\u0730-\u074c]/gu,V=/[\p{M}]|[\u0701-\u0709]|[\u0730-\u074c]/u,W=/(?![\u0701-\u0709]|[\u0730-\u074c])[^\p{M}]/u;class g{constructor(t){d(this,"id",J());d(this,"str");d(this,"_nfd",null);d(this,"_stripped",null);d(this,"_chunks",null);this.str=t}static addFlagIfAbsent(t,s){return t.includes(s)?t:t+s}get nfd(){return this._nfd||this.cacheNFD(),this._nfd}get stripped(){return this._stripped||this.cacheStripped(),this._stripped}get chunks(){return this._chunks||this.cacheChunks(),this._chunks||[]}cacheNFD(){this._nfd||(this._nfd=this.str.normalize("NFD"))}cacheStripped(){var t;this._stripped||(this._stripped=((t=this.nfd)==null?void 0:t.replace(O,""))||"")}cacheChunks(){this._chunks||(this._chunks=this.str===this.stripped?this.str.split(""):this.makeNFDChunks())}makeNFDChunks(){var n;const t=((n=this.nfd)==null?void 0:n.split(""))||[],s=[];let e=0;s[e]="";for(let a=0;a<t.length;a++)s[e]+=t[a],a+1<t.length&&!V.test(t[a+1])&&W.test(s[e])&&(e++,s[e]="");return s}splitInclusive(t){t=RegExp(t.source,g.addFlagIfAbsent(t.flags,"g"));const s=Array.from(this.stripped.matchAll(t)),e=[];let n=0;for(const a of s){const c=a[0].length,i=a.index;e.push(this.chunks.slice(n,i).join("")),e.push(this.chunks.slice(i,i+c).join("")),n=i+c}return e.push(this.chunks.slice(n).join("")),e}}const X="aramaic-site",p="store",f=G(X,1,{upgrade(r){if(!r.objectStoreNames.contains(p))return r.createObjectStore(p)}});class R{static async get(t){return(await f).get(p,t)}static async set(t,s){return(await f).put(p,s,t)}static async delete(t){return(await f).delete(p,t)}static async clear(){return(await f).clear(p)}static async keys(){return(await f).getAllKeys(p)}}const _=(r,t)=>{const s=K(r),e=y({get:()=>{switch(s.value){case"true":return!0;case"false":return!1}},set:n=>{switch(n){case!0:s.value="true";break;case!1:s.value="false";break}}});return b.isBoolean(t)&&(e.value=t),e},H="ʔbgdhYwzḥṭyklmnsʕpṣqršt",Q="AbgdhYwzHTyklmnsCpSqrWt",Y="ܐܒܓܕܗܞܘܙܚܛܝܟܠܡܢܣܥܦܨܩܪܫܬ",[C,D,U]=[H,Q,Y].map(r=>r.split("")),rt={translitArr:C,translitAnsiArr:D,originalLettersArr:U},nt={pot:{name:"POT with Western vowels"},pnt:{name:"PNT with Western vowels"},syr:{name:"Syriac Corpus"}},at=F("syriacCorpusStore",()=>{const r=j(),t=T([]),s=k(""),e=k(!1),n=_("simpleSymbols"),a=_("translit"),c=_("ignoreDiacritics"),i=y(()=>n.value?D:C),S=y(()=>{const u=s.value;return c.value?a.value?i.value.reduce((o,v,l)=>{const h=U[l],N=RegExp("(?<!\\\\)"+v,"gu");return o.replace(N,h)},u):new g(u).stripped:u}),x=y(()=>{if(!s.value)return[];const u=RegExp(S.value,"u");return c.value?t.value.filter(o=>u.test(o.line.stripped)):t.value.filter(o=>u.test(o.line.str))});async function I(u){t.value=[],e.value=!0;const o=u.map(l=>{switch(l){case"pot":return w.potJson;case"pnt":return w.pntJson;case"syr":default:return w.syrJson}}).flatMap(l=>{var h;return((h=r[l])==null?void 0:h.data)||[]}),v=await Z(o);t.value=v.map(({filename:l,line:h})=>({filename:l,line:new g(h)})),e.value=!1}return{corpus:t,searchString:s,isPreprocessingSyriacCorpus:e,isSimpleSymbols:n,isTranslit:a,doIgnoreDiacritics:c,activeTranslitArr:i,finalSearchString:S,matchingSyriacLines:x,initSyriacCorpus:I}});async function Z(r){const t=await B(r),s=await R.get("syriacCorpus")||{},e=s[t];if(e)return e;const n=r.flatMap(({filename:a,text:c})=>c.split(/\n+/).map(b.trim).map(i=>({filename:a,line:i})));return s[t]=n,await R.set("syriacCorpus",s),n}export{R as I,nt as S,_ as a,rt as s,at as u};
