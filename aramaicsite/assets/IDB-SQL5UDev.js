var w=Object.defineProperty;var h=(n,t,e)=>t in n?w(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var c=(n,t,e)=>h(n,typeof t!="symbol"?t+"":t,e);import{o as a}from"./index-Dob3nYDb.js";class d{constructor(t){c(this,"upgradeQueuePromise",Promise.resolve());this.dbName=t}async getVersion(){return new Promise((t,e)=>{const r=indexedDB.open(this.dbName);r.onsuccess=()=>{const s=r.result,o=s.version;s.close(),t(o)},r.onerror=()=>e(r.error)}).catch(()=>1)}async _openDBRaw(t){let e=await a(this.dbName);if(e.objectStoreNames.contains(t))return e.close(),e=await a(this.dbName),e;e.close();const s=await this.getVersion()+1;return await a(this.dbName,s,{upgrade(o){o.objectStoreNames.contains(t)||o.createObjectStore(t)}})}async _openDB(t){return this.upgradeQueuePromise=this.upgradeQueuePromise.then(this._openDBRaw.bind(this,t)),await this.upgradeQueuePromise,await a(this.dbName)}async set(t,e,r){const o=(await this._openDB(t)).transaction(t,"readwrite");await o.store.put(r,e),await o.done}async get(t,e){const s=(await this._openDB(t)).transaction(t,"readonly"),o=await s.store.get(e);return await s.done,o}}const i=new Map;function u(n){return i.has(n)||i.set(n,new d(n)),i.get(n)}class B{static async get(t,e,r){try{return await u(t).get(e,r)}catch(s){throw console.error(`[IDB] Error getting from ${t}/${e}/${r}:`,s),s}}static async set(t,e,r,s){try{await u(t).set(e,r,s)}catch(o){throw console.error(`[IDB] Error setting to ${t}/${e}/${r}:`,o),o}}}export{B as I};
