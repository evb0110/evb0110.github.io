var E=Object.defineProperty;var L=(r,t,s)=>t in r?E(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var d=(r,t,s)=>L(r,typeof t!="symbol"?t+"":t,s);import{aO as M,c as y,J as C,d as j,aj as F,r as k,aP as T}from"./index-CpyHOb2A.js";import{u as P,A as _}from"./assetsStore-Dt13O2fd.js";import{o as B}from"./index-Dob3nYDb.js";import{u as G}from"./index-CcdasFf7.js";var m,J=new Uint8Array(16);function K(){if(!m&&(m=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!m))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return m(J)}var O=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const A={randomUUID:O};function q(r,t,s){if(A.randomUUID&&!t&&!r)return A.randomUUID();r=r||{};var e=r.random||(r.rng||K)();return e[6]=e[6]&15|64,e[8]=e[8]&63|128,M(e)}const z=/[\p{M}]|[\u0701-\u0709]|[\u0730-\u074c]/gu,V=/[\p{M}]|[\u0701-\u0709]|[\u0730-\u074c]/u,W=/(?![\u0701-\u0709]|[\u0730-\u074c])[^\p{M}]/u;class g{constructor(t){d(this,"id",q());d(this,"str");d(this,"_nfd",null);d(this,"_stripped",null);d(this,"_chunks",null);this.str=t}static addFlagIfAbsent(t,s){return t.includes(s)?t:t+s}get nfd(){return this._nfd||this.cacheNFD(),this._nfd}get stripped(){return this._stripped||this.cacheStripped(),this._stripped}get chunks(){return this._chunks||this.cacheChunks(),this._chunks||[]}cacheNFD(){this._nfd||(this._nfd=this.str.normalize("NFD"))}cacheStripped(){var t;this._stripped||(this._stripped=((t=this.nfd)==null?void 0:t.replace(z,""))||"")}cacheChunks(){this._chunks||(this._chunks=this.str===this.stripped?this.str.split(""):this.makeNFDChunks())}makeNFDChunks(){var n;const t=((n=this.nfd)==null?void 0:n.split(""))||[],s=[];let e=0;s[e]="";for(let a=0;a<t.length;a++)s[e]+=t[a],a+1<t.length&&!V.test(t[a+1])&&W.test(s[e])&&(e++,s[e]="");return s}splitInclusive(t){t=RegExp(t.source,g.addFlagIfAbsent(t.flags,"g"));const s=Array.from(this.stripped.matchAll(t)),e=[];let n=0;for(const a of s){const c=a[0].length,i=a.index;e.push(this.chunks.slice(n,i).join("")),e.push(this.chunks.slice(i,i+c).join("")),n=i+c}return e.push(this.chunks.slice(n).join("")),e}}const X="aramaic-site",p="store",f=B(X,1,{upgrade(r){if(!r.objectStoreNames.contains(p))return r.createObjectStore(p)}});class R{static async get(t){return(await f).get(p,t)}static async set(t,s){return(await f).put(p,s,t)}static async delete(t){return(await f).delete(p,t)}static async clear(){return(await f).clear(p)}static async keys(){return(await f).getAllKeys(p)}}const w=(r,t)=>{const s=G(r),e=y({get:()=>{switch(s.value){case"true":return!0;case"false":return!1}},set:n=>{switch(n){case!0:s.value="true";break;case!1:s.value="false";break}}});return C.isBoolean(t)&&(e.value=t),e},H="ʔbgdhYwzḥṭyklmnsʕpṣqršt",Q="AbgdhYwzHTyklmnsCpSqrWt",Y="ܐܒܓܕܗܞܘܙܚܛܝܟܠܡܢܣܥܦܨܩܪܫܬ",[b,D,U]=[H,Q,Y].map(r=>r.split("")),nt={translitArr:b,translitAnsiArr:D,originalLettersArr:U},at={pot:{name:"POT with Western vowels"},pnt:{name:"PNT with Western vowels"},syr:{name:"Syriac Corpus"}},it=j("syriacCorpusStore",()=>{const r=P(),t=F([]),s=k(""),e=k(!1),n=w("simpleSymbols"),a=w("translit"),c=w("ignoreDiacritics"),i=y(()=>n.value?D:b),S=y(()=>{const o=s.value;return c.value?a.value?i.value.reduce((u,v,l)=>{const h=U[l],N=RegExp("(?<!\\\\)"+v,"gu");return u.replace(N,h)},o):new g(o).stripped:o}),x=y(()=>{if(!s.value)return[];const o=RegExp(S.value,"u");return c.value?t.value.filter(u=>o.test(u.line.stripped)):t.value.filter(u=>o.test(u.line.str))});async function I(o){t.value=[],e.value=!0;const u=o.map(l=>{switch(l){case"pot":return _.potJson;case"pnt":return _.pntJson;case"syr":default:return _.syrJson}}).flatMap(l=>{var h;return((h=r[l])==null?void 0:h.data)||[]}),v=await Z(u);t.value=v.map(({filename:l,line:h})=>({filename:l,line:new g(h)})),e.value=!1}return{corpus:t,searchString:s,isPreprocessingSyriacCorpus:e,isSimpleSymbols:n,isTranslit:a,doIgnoreDiacritics:c,activeTranslitArr:i,finalSearchString:S,matchingSyriacLines:x,initSyriacCorpus:I}});async function Z(r){const t=await T(r),s=await R.get("syriacCorpus")||{},e=s[t];if(e)return e;const n=r.flatMap(({filename:a,text:c})=>c.split(/\n+/).map(C.trim).map(i=>({filename:a,line:i})));return s[t]=n,await R.set("syriacCorpus",s),n}export{R as I,at as S,w as a,nt as s,it as u};
